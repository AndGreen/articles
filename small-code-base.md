
# Large vs Small

Маленькие кодовые базы (например, утилиты, embedded-проекты, демо) и крупные enterprise-системы (например, банковские сервисы, ERP) действительно отличаются архитектурой, подходом к моделированию и приоритетами. Разберём ключевые различия:

## 1. Доменное моделирование (Domain-Driven Design, DDD)

### Large Software Systems (Enterprise)

Обязательно:
- Чёткое разделение на сущности (User, Order), агрегаты, сервисы.
- Сложный Ubiquitous Language (единый язык между разработчиками и бизнесом).
- Паттерны Repository, CQRS, Event Sourcing.

**Пример:**
```java
// Типичный enterprise-код (Java + Spring)
@Entity
public class User {
    @Id private UUID id;
    private String email;
    @OneToMany private List<Order> orders;
}

@Service
public class UserService {
    @Transactional
    public User createUser(UserDto dto) { ... }
}
```

### Маленькие кодовые базы

- Часто отсутствует:
  - Нет сложных агрегатов — только структуры данных (struct, enum).
  - Модель ближе к алгоритму или железу, а не к бизнес-логике.

**Пример:**
```rust
// Минималистичная модель (Rust для embedded)
struct SensorReading {
    temp: f32,
    timestamp: u64,
}

fn read_sensor() -> SensorReading { ... }
```

**Почему?**
- Нет бизнес-правил (например, "пользователь не может заказать больше 10 товаров").
- Данные часто линейны (поток байт, показания датчика).

## 2. Архитектура

### Large Systems

- Многослойность:
  - API → Service → Repository → Database.
  - Микросервисы, Message Queues (Kafka).
- Инфраструктура:
  - Контейнеризация (Docker), оркестрация (Kubernetes).

### Маленькие проекты

- Плоская структура:
  - Часто всё в одном файле (`main.c`).
  - Нет слоёв — данные сразу преобразуются.

**Пример:**
```c
// UNIX-утилита (cat-подобная)
int main() {
    char buf[1024];
    while (fgets(buf, sizeof(buf), stdin)) {
        process(buf); // Всё в одной функции
    }
}
```

## 3. Управление состоянием (State)

### Enterprise

- Глобальное состояние:
  - Базы данных, кеши (Redis), сессии.
  - Транзакции (`@Transactional`).

### Маленькие системы

- Локальное состояние:
  - Переменные в стеке, регистры микроконтроллера.
  - Чистые функции (вход → выход).

**Пример:**
```python
# Чистая функция (нет состояния)
def square(x): 
    return x * x
```

## 4. Тестирование

### Enterprise

- Юнит-тесты, интеграционные тесты, моки.
- Покрытие 80%+ (из-за сложности бизнес-логики).

### Маленькие проекты

- Тесты часто отсутствуют (или только smoke-тесты).
- Проверка вручную:
  - Запустил → увидел результат.
  - Критично для демосцены: бинарник должен работать.

## 5. Зависимости (Dependencies)

### Enterprise

- Десятки библиотек:
  - Spring, Hibernate, Kafka Client.
  - Сложность обновлений.

### Маленькие проекты

- Минимум зависимостей:
  - Часто только стандартная библиотека.
  - Иногда весь код в одном файле (например, [SQLite](https://sqlite.org/)).

## 6. Почему в малых проектах нет DDD?

1. Нет сложной предметной области:
   - Нет "пользователей", "заказов", "платежей" — только данные.
2. Жёсткие ограничения:
   - 64KB памяти → нельзя позволить себе лишние абстракции.
3. Код = алгоритм:
   - Например, FFT (преобразование Фурье) описывается формулой, а не бизнес-правилами.

## Когда маленький проект становится большим?

Иногда масштабирование ломает архитектуру. Пример:
- Изначально: `nginx` был компактным.
- Сейчас: Поддержка HTTP/3, Lua-скрипты → усложнение.

**Как избежать:**
- Заранее выделять границы модулей (даже в маленьком коде).
- Избегать хаотичного роста фич.

## Итог: Что выбрать?

- **Enterprise (DDD, слои):**
  - Если есть бизнес-логика (банки, маркетплейсы).
- **Минимализм (flat, алгоритмы):**
  - Для утилит, embedded, демо.

**Пример перехода:**  
Даже в маленьком проекте можно добавить элементы DDD, если он растёт:

```rust
// Было: Плоская структура
struct Data { ... }

// Стало: Агрегат
struct User {
    id: UserId,
    orders: Vec<Order>,
}

impl User {
    fn place_order(&mut self, item: Item) -> Result<(), Error> { ... }
}
```
